! ESTA SUBROTINA PRINCIPAL É AQUELA EM QUE SE EFETUAM OS CÁLCULOS PARA SIMULAÇÃO


SUBROUTINE PRINCIPAL_SIM(ESCREVE_CABECALHO,K1RESET,K2RESET,K3RESET,FONTE,COMPDOMX,NIINIC,COMPDOMY,MJINIC,NB,&
                    PARCOND_I,CONDCONTORNO,VELOCIDADE,DELTA_T,T_FIN,W_SOL,TOL_SOL,&
                    IT_SOL,TOL_PER,AM_FRAM,TOL_OCUP,DADOS_LAMBDA,DADOS_GAMMA_X,DADOS_GAMMA_Y,POP_C,EXT_SN)
                       
                       
                       
IMPLICIT NONE 
 
 TYPE::DOMINIO
	REAL(KIND=10)	::DOM1 ; REAL(KIND=10) ::DOM2 ; &
	CHARACTER(3) 	::DOM3
 END TYPE
 
 TYPE::FONTE_INIC
	INTEGER        ::BL3  ; &
	REAL(KIND=10)  ::K1IN,K1STEP,K1END,K2IN,K2STEP,K2END,K3IN,K3STEP,K3END ; &
	CHARACTER(14)  ::MOD_F
				  !EXPONENCIAL:     F = K1*S, 
				  !LOGISTICO:       F = K1*S*(1.0-S/K2), 
				  !GOLPERTZ:        F = K1*S*ln(K2/S), 
				  !ALLEE:           F = K1*S*(1.0-S/K2)*(S/K3-1.0)
 END TYPE
 
 TYPE::CONDICOES_INIC
	INTEGER 	::BL1 ; &
	REAL(KIND=10)	::S_I_A ; REAL(KIND=10) ::S_I_B ; REAL(KIND=10) ::S_I_C ; &
    REAL(KIND=10)   ::S_I_D ; REAL(KIND=10) ::S_I_E ; &
	CHARACTER(13) 	::S_I_FUN
 END TYPE
 
 TYPE::CONDICOES_CONT
	INTEGER 	::PRI 
	REAL(KIND=10)	::CC1W ; REAL(KIND=10) ::CC2W
	REAL(KIND=10)	::CC1E ; REAL(KIND=10) ::CC2E
	REAL(KIND=10)	::CC1S ; REAL(KIND=10) ::CC2S
	REAL(KIND=10)	::CC1N ; REAL(KIND=10) ::CC2N
 END TYPE
 
 TYPE::F_LAMBDA
	INTEGER        ::BL4  ; &
	REAL(KIND=10)  ::L_ZERO ; &
	CHARACTER(13)  ::MOD_LAMBDA
				  !CONSTANTE:       LAMBDA = L_ZERO 
				  !TIAGO:           LAMBDA = L_ZERO + L_ZERO*(DELTA_OCUP + DELTA_POP)

 END TYPE
 
 TYPE::F_GAMMA
	INTEGER        ::BL5  ; &
	REAL(KIND=10)  ::GAMMA_ZERO ; &
	CHARACTER(13)  ::MOD_GAMMA

 END TYPE
 
 !DECLARAÇÃO DAS VARIÁVEIS DA SUBROTINA
 LOGICAL,INTENT(IN)                             ::ESCREVE_CABECALHO
 CHARACTER(3),INTENT(IN)                        ::EXT_SN
 !CHARACTER(7),INTENT(IN)	                    ::EXI,METODO_CONVECTIVO,
 INTEGER,INTENT(IN)				                ::NIINIC,MJINIC,NB,IT_SOL,AM_FRAM
 REAL(KIND=10),INTENT(IN)	                    ::K1RESET,K2RESET,K3RESET,VELOCIDADE,W_SOL
 REAL(KIND=10),INTENT(IN)	                    ::DELTA_T,T_FIN,TOL_SOL,TOL_PER,TOL_OCUP,POP_C
 TYPE(FONTE_INIC),DIMENSION(NB),INTENT(IN)	    ::FONTE
 TYPE(DOMINIO),INTENT(IN)			            ::COMPDOMX,COMPDOMY
 TYPE(CONDICOES_INIC),DIMENSION(NB),INTENT(IN)	::PARCOND_I
 TYPE(CONDICOES_CONT),DIMENSION(NB),INTENT(IN)	::CONDCONTORNO
 TYPE(F_LAMBDA),DIMENSION(NB),INTENT(IN)	    ::DADOS_LAMBDA
 TYPE(F_GAMMA),DIMENSION(NB),INTENT(IN)	        ::DADOS_GAMMA_X,DADOS_GAMMA_Y
 

 
 !DECLARAÇÃO DAS VARIÁVEIS LOCAIS
 CHARACTER	                                ::CASO_SA
 LOGICAL                                    ::CONFIRM
 INTEGER	                                ::NI,MJ,CICLO,MANIPULA
 REAL(KIND=10)                              ::K1VAR,K2VAR,K3VAR!,S0,SNI
 REAL(KIND=10)                              ::COMP_DOMI,COMP_DOMJ,DELTA_X,DELTA_Y,T,VEL_X,VEL_Y
 !REAL(KIND=10)	                            ::ERRO,S_PAS0,S_PASNI
 !REAL(KIND=10)	                            ::T,PARCELA_TEMPORAL,PN,CONFIRM_IN,CONFIRM_END
 !REAL(KIND=10)	                            ::PARCELA_D,PARCELA_A,PARCELA_R
 !REAL(KIND=10),DIMENSION(:),ALLOCATABLE    ::B,SAN,S,S_PAS,S_PAS_PAS
 REAL(KIND=10),DIMENSION(:),ALLOCATABLE     ::X,Y,XS,YS
 !REAL(KIND=10),DIMENSION(:),ALLOCATABLE    ::UCAR_PERMANENTE,UCAR,UCAR_PAS
 REAL(KIND=10),DIMENSION(:,:),ALLOCATABLE   ::S2D,S2D_PAS,S2D_PAS_PAS
 REAL(KIND=10),DIMENSION(:,:),ALLOCATABLE   ::S2D_LAMBDA, S2D_VEL_X, S2D_VEL_Y, S2D_VS
 REAL(KIND=10)                              ::LAMBDA,OCUP,POP,POP_PAS,POP_MAX
 REAL(KIND=10)                              ::ERRO_ESTACIONARIO,TIMER_INIC,TIMER_FIM

 !VARIAVEIS PARA DEBUG
 !TYPE(DOMINIO)			              ::COMPDOM
 !TYPE(CONDICOES_INIC),DIMENSION(NB)  ::PARCOND_I_FAKE
 !INTEGER                             ::CONT
 INTEGER                              ::FRAME,FRAME_CONT
 CHARACTER(13)                        ::NOMEARQ
 CHARACTER(6)                         ::NOMEARQ_N
 LOGICAL                              ::CONVERGE,NEG_ENCONTRADO
 
 
 !DEBUG
 NOMEARQ='S2D000000.dat'
 NEG_ENCONTRADO=.FALSE.
 CALL CPU_TIME(TIMER_INIC)
 
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !!! CONDICAO PARA REALIZAR A SIMULACAO !!!
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 K3VAR = K3RESET ; K2VAR = K2RESET ; K1VAR = K1RESET
 
 FAIXA_PERMITIDA2: IF ( ((FONTE(1)%MOD_F == 'ALLEE').AND.(K3VAR<K2VAR)).OR.&
                    (FONTE(1)%MOD_F == 'LOGISTICO').OR.(FONTE(1)%MOD_F == 'EXPONENCIAL') ) THEN
 
 
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !!! ALOCACAO DE VARIAVEIS !!!
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
 !VARIAVEIS DO DOMINIO
 
 COMP_DOMI = COMPDOMX%DOM2 ; NI = NIINIC
 COMP_DOMJ = COMPDOMY%DOM2 ; MJ = MJINIC
 
 ALLOCATE (X(NI+2),Y(MJ+2),XS(NI+1),YS(MJ+1))
 
 
 !VARIAVEIS DA IMAGEM
 
 ALLOCATE(S2D(MJ+1,NI+1),S2D_PAS(MJ+1,NI+1),S2D_PAS_PAS(MJ+1,NI+1))
 
 
 !MATRIZES DE PARAMETROS
 
 ALLOCATE(S2D_LAMBDA(MJ+1,NI+1),S2D_VEL_X(MJ+1,NI+1),S2D_VEL_Y(MJ+1,NI+1),S2D_VS(MJ+1,NI+1))
 
 
 !RESET DAS VARIAVEIS
 
 X=0.0; Y=0.0; XS=0.0; YS=0.0
 S2D=0.0; S2D_PAS=0.0; S2D_PAS=0.0
 S2D_LAMBDA=1.0; S2D_VEL_X=0.0; S2D_VEL_Y=0.0; S2D_VS=0.0
 ERRO_ESTACIONARIO=0.0

 
 !RESET DAS VARIAVEIS DA SIMULACAO
 CICLO=0; T=0.0
 
 
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !!! CRIACAO DA MALHA COMPUTACIONAL !!!
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
 CALL MALHA(COMPDOMX,NI,COMP_DOMI,DELTA_X,X,XS)
 CALL MALHA(COMPDOMY,MJ,COMP_DOMJ,DELTA_Y,Y,YS)
 
 
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !!! PREPARACAO INICIAL DA SIMULACAO !!!
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    
 
 ! CONDICOES INICIAIS
 
 CALL COND_INICIAIS2D(COMPDOMX,COMPDOMY,NI,MJ,NB,COMP_DOMI,COMP_DOMJ,PARCOND_I,X,Y,XS,YS,S2D)
 
 
 ! INICIALIZACAO DOS TEMPOS PASSADOS !
 
 S2D_PAS=S2D; S2D_PAS_PAS=S2D
 
 
 ! CONDICOES DE CONTORNO
 
 CALL COND_CONTORNO2D(NI,MJ,NB,CONDCONTORNO,DELTA_X,DELTA_Y,S2D,S2D_PAS)
 
 
 ! POPULACAO INICIAL
 
 CALL INTEGRAL2D(NI,MJ,DELTA_X,DELTA_Y,S2D,POP)
 
 
 ! OCUPACAO INICIAL
 
 CALL OCUPACAO2D(NI,MJ,TOL_OCUP,S2D,OCUP)
 
 ! POPULACAO MAXIMA (CASO EXPONENCIAL)
 IF (FONTE(1)%MOD_F == 'EXPONENCIAL') THEN
 POP_MAX = POP_C*COMP_DOMI*COMP_DOMJ*MAXVAL(S2D)
 END IF
 
 
 ! GRAVACAO DAS CONDICOES INICIAIS
 
 CALL GRAVACAO_S2D(NI,MJ,XS,YS,S2D,NOMEARQ,T)
 
 MANIPULA = SYSTEM('if test -e '//NOMEARQ//'; then mv '//NOMEARQ//' SAI_PD; fi;')
 
 
 ! PREPARA ARQUIVO QUANTIDADES DE INTERESSE
 
 OPEN(1,FILE='QUANT_POPULACIONAL.dat',STATUS='NEW')
 
 CALL QUANTIDADES(NB,CICLO,NI,MJ,DELTA_X,DELTA_Y,DELTA_T,S2D_VEL_X,S2D_VEL_Y,FONTE,T,S2D,S2D_PAS,S2D_PAS_PAS,&
                  K1VAR,K2VAR,K3VAR,POP,OCUP,S2D_LAMBDA,ERRO_ESTACIONARIO)
 
 CLOSE(1)
 
 
 ! PREPARA ARQUIVO DE MONITORAMENTO NEGATIVO
 
 OPEN(2,FILE='EVO_NEGATIVA.dat',STATUS='NEW')
 
 WRITE(2,*) '#ARQUIVO DE REGISTRO DE VALORES NEGATIVOS#'
 WRITE(2,20)
 20 FORMAT(7X,'TEMPO',12X,'CICLO',12X,'FRAME',12X,'COUNT',14X,'MINVAL')
 
 CLOSE(2)
 
 
 ! PREPARA FRAME E CONTAGEM DE FRAME
 FRAME=1; FRAME_CONT=0
 
 
 ! ABRE ARQUIVOS PARA GRAVACAO
 
 OPEN(1,FILE='QUANT_POPULACIONAL.dat',STATUS='OLD',POSITION='APPEND')
 
 OPEN(2,FILE='EVO_NEGATIVA.dat',STATUS='OLD',POSITION='APPEND')
 
 
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !!!        LACO TEMPORAL       !!!
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
 !PREPARA PRIMEIRA ITERACAO
 T = T + DELTA_T; CICLO = CICLO + 1; FRAME_CONT = FRAME_CONT + 1
 
 VARIACAO_T: DO WHILE (T <= T_FIN + 0.00000001)
 

 PRINT*,'TEMPO ATUAL:',T
 PRINT*,'CICLO ATUAL:',CICLO,'FRAME:',FRAME
 
 
 !APLICA CONDICOES DE CONTORNO
 
 CALL COND_CONTORNO2D(NI,MJ,NB,CONDCONTORNO,DELTA_X,DELTA_Y,S2D,S2D_PAS)
 
 !ATUALIZA TEMPOS PASSADOS
 
 S2D_PAS_PAS=S2D_PAS; S2D_PAS=S2D; POP_PAS = POP
 
 !CALCULA EQUACAO
 
 IF ((DADOS_LAMBDA(1)%MOD_LAMBDA == 'ELIANDRO') .OR. (DADOS_LAMBDA(1)%MOD_LAMBDA == 'ELIANDRO2')) THEN !USA O CODIGO ESPECIFICO
 
 CALL EQUACAO_S2D_ELIANDRO(NB,NI,MJ,DELTA_X,DELTA_Y,XS,YS,DELTA_T,FONTE,K1VAR,K2VAR,K3VAR,IT_SOL,W_SOL,TOL_SOL,&
            S2D_PAS,S2D_PAS_PAS,S2D,DADOS_LAMBDA,OCUP,TOL_OCUP,POP,POP_PAS,DADOS_GAMMA_X,DADOS_GAMMA_Y,&
            S2D_LAMBDA,S2D_VEL_X,S2D_VEL_Y,S2D_VS,CONVERGE)
            
 ELSE                                               !USA O CODIGO GERAL
            
 CALL EQUACAO_S2D(NB,NI,MJ,DELTA_X,DELTA_Y,XS,YS,DELTA_T,FONTE,K1VAR,K2VAR,K3VAR,IT_SOL,W_SOL,TOL_SOL,&
            S2D_PAS,S2D_PAS_PAS,S2D,DADOS_LAMBDA,OCUP,TOL_OCUP,POP,POP_PAS,DADOS_GAMMA_X,DADOS_GAMMA_Y,&
            S2D_LAMBDA, S2D_VEL_X, S2D_VEL_Y,CONVERGE)
            
 END IF
 
 ! VERIFICA CONVERGENCIA
 IF (.NOT. CONVERGE) THEN
 PRINT*,'CICLO',CICLO,'DIVERGIU'
 GO TO 102
 END IF
 
 
 !GRAVA SOLUCAO
 
 GRAVA_DADOS: IF (FRAME_CONT >= AM_FRAM) THEN
 
 !GRAVA SOLUCAO
 WRITE(NOMEARQ_N,'(I0.6)') FRAME
 NOMEARQ='S2D'//NOMEARQ_N//'.dat'
 CALL GRAVACAO_S2D(NI,MJ,XS,YS,S2D,NOMEARQ,T)
 MANIPULA = SYSTEM('if test -e '//NOMEARQ//'; then mv '//NOMEARQ//' SAI_PD; fi;')
 
 !PRINT*, NOMEARQ
 
 !GRAVA VELOCIDADE X (SOMENTE SE NAO FOR CONSTANTE)
 IF (DADOS_GAMMA_X(1)%MOD_GAMMA .NE. 'CONSTANTE') THEN
 WRITE(NOMEARQ_N,'(I0.6)') FRAME
 NOMEARQ='GMX'//NOMEARQ_N//'.dat'
 CALL GRAVACAO_S2D(NI,MJ,XS,YS,S2D_VEL_X,NOMEARQ,T)
 MANIPULA = SYSTEM('if test -e '//NOMEARQ//'; then mv '//NOMEARQ//' SAI_PD/GAMMAX; fi;')
 END IF
 
 !GRAVA VELOCIDADE Y (SOMENTE SE NAO FOR CONSTANTE)
 IF (DADOS_GAMMA_Y(1)%MOD_GAMMA .NE. 'CONSTANTE') THEN
 WRITE(NOMEARQ_N,'(I0.6)') FRAME
 NOMEARQ='GMY'//NOMEARQ_N//'.dat'
 CALL GRAVACAO_S2D(NI,MJ,XS,YS,S2D_VEL_Y,NOMEARQ,T)
 MANIPULA = SYSTEM('if test -e '//NOMEARQ//'; then mv '//NOMEARQ//' SAI_PD/GAMMAY; fi;')
 END IF
 
 !GRAVA LAMBDA (SOMENTE SE NAO FOR CONSTANTE)
 IF (DADOS_LAMBDA(1)%MOD_LAMBDA .NE. 'CONSTANTE') THEN
 WRITE(NOMEARQ_N,'(I0.6)') FRAME
 NOMEARQ='LDA'//NOMEARQ_N//'.dat'
 CALL GRAVACAO_S2D(NI,MJ,XS,YS,S2D_LAMBDA,NOMEARQ,T)
 MANIPULA = SYSTEM('if test -e '//NOMEARQ//'; then mv '//NOMEARQ//' SAI_PD/LAMBDA; fi;')
 END IF
 
 !GRAVA VS (SE LAMBDA FOR ELIANDRO)
 IF (DADOS_LAMBDA(1)%MOD_LAMBDA == 'ELIANDRO') THEN
 WRITE(NOMEARQ_N,'(I0.6)') FRAME
 NOMEARQ='VS'//NOMEARQ_N//'.dat'
 CALL GRAVACAO_S2D(NI,MJ,XS,YS,S2D_VS,NOMEARQ,T)
 MANIPULA = SYSTEM('if test -e '//NOMEARQ//'; then mv '//NOMEARQ//' SAI_PD/VS; fi;')
 END IF
 
 !ATUALIZA FRAME
 FRAME = FRAME+1
 
 !RESETA CONTADOR DE FRAME
 FRAME_CONT = 0
 
 END IF GRAVA_DADOS
 
 
 !CALCULA E ESCREVE QUANTIDADES
 
 CALL QUANTIDADES(NB,CICLO,NI,MJ,DELTA_X,DELTA_Y,DELTA_T,S2D_VEL_X,S2D_VEL_Y,FONTE,T,S2D,S2D_PAS,S2D_PAS_PAS,&
                  K1VAR,K2VAR,K3VAR,POP,OCUP,S2D_LAMBDA,ERRO_ESTACIONARIO)
 
 
 !CALCULA ESTADO ESTACIONARIO
 
 ERRO_ESTACIONARIO=NORM2(S2D-S2D_PAS)/NORM2(S2D)
 !PRINT*, 'ERRO ESTACIONARIO=',ERRO_ESTACIONARIO
 
 
 !CONDICAO DE EXISTENCIA PARA A SIMULACAO, NAO PODE EXISTIR DENSIDADE POPULACIONAL NEGATIVA
 
 IF (MINVAL(S2D) < 0.0) THEN
 PRINT*,'VALOR NEGATIVO ENCONTRADO'
 NEG_ENCONTRADO=.TRUE.
 WRITE(2,21) T, CICLO, FRAME, FRAME_CONT, MINVAL(S2D)
 21 FORMAT(F12.6,11X,I0.6,11X,I0.6,11X,I0.6,8X,F12.8)
 END IF
 
 
 !QUEBRA DE CICLO
 
 IF ((OCUP == 0.0) .AND. (EXT_SN=='SIM')) THEN                      !OCUPACAO ZERO
 PRINT '(" EXTINCAO EM T= ",F12.3)',T
 GO TO 102
 END IF
 
 IF ((FONTE(1)%MOD_F == 'EXPONENCIAL') .AND. (POP > POP_MAX)) THEN  !ESTOURO DE POPULACAO
 PRINT '(" ESTOURO DE POPULACAO EM T= ",F12.3)',T
 GO TO 102
 END IF
 
 
 !ATUALIZA CICLO
 
 T = T + DELTA_T; CICLO = CICLO + 1; FRAME_CONT = FRAME_CONT + 1
  
 END DO VARIACAO_T
 

 
 
 !!!!!!!!!!!!!!!!!!!!!!!!
 !!! FIM DA SIMULACAO !!!
 !!!!!!!!!!!!!!!!!!!!!!!!
 

 
 END IF FAIXA_PERMITIDA2
 
 
 102 CONTINUE
 
 !FECHA ARQUIVOS DE GRAVACAO
 CLOSE(1)
 CLOSE(2)
 
 
 
 !MENSAGENS FINAIS
 !PRINT*,'DELTA_X=',DELTA_X
 !PRINT*,'DELTA_Y=',DELTA_Y
 PRINT*,'NORMA S2D',NORM2(S2D)
 
 IF (NEG_ENCONTRADO) THEN
 PRINT*,'RESULTADO NEGATIVO ENCONTRADO'
 ELSE
 PRINT*,'NENHUM RESULTADO NEGATIVO'
 END IF
 
 CALL CPU_TIME(TIMER_FIM)
 PRINT '(" TEMPO DE EXECUCAO = ",F12.3," MINUTOS.")',(TIMER_FIM-TIMER_INIC)/60

 
 END SUBROUTINE PRINCIPAL_SIM
